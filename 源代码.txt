import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import csv
from datetime import datetime, timedelta
import sys
import os
import ctypes
from collections import defaultdict
import threading
import time
import socket
import uuid
import hashlib
import json
import random
import pygame
import qrcode
from PIL import Image, ImageTk
import matplotlib

matplotlib.use('Agg')  # 修复matplotlib在Tkinter中的兼容性问题

try:
    from wordcloud import WordCloud
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.metrics.pairwise import cosine_similarity
    from ip2region import Ip2Region
    from pyecharts.charts import Geo
    from pyecharts import options as opts
except ImportError as e:
    print(f"缺少依赖库: {e}")

# ---------- 隐藏控制台窗口的跨平台逻辑 ----------
if sys.platform == 'win32':
    whnd = ctypes.windll.kernel32.GetConsoleWindow()
    if whnd != 0:
        ctypes.windll.user32.ShowWindow(whnd, 0)
elif sys.platform == 'darwin':
    sys.stdout = open(os.devnull, 'w')
    sys.stderr = open(os.devnull, 'w')


class StyleConfig:
    """样式配置集中管理"""
    PRIMARY = "#2C3E50"
    SECONDARY = "#3498DB"
    BACKGROUND = "#ECF0F1"
    TEXT = "#2C3E50"
    FONT_TITLE = ("微软雅黑", 18, "bold")
    FONT_NORMAL = ("微软雅黑", 12)
    BTN_PADDING = 10
    CORNER_RADIUS = 8
    CHART_COLORS = ["#3498DB", "#2ECC71", "#E74C3C", "#9B59B6", "#F1C40F", "#1ABC9C"]
    CARD_SHADOW = "#D0D3D4"
    TIMER_COLOR = "#E67E22"
    ACCENT = "#27AE60"


class VotingApp:
    def __init__(self, root):
        self.root = root
        self.root.title("极简投票系统")
        self.root.geometry("1366x900")
        self.style = ttk.Style()
        self._configure_styles()

        # 初始化数据结构
        self.candidates = []
        self.votes = {}
        self.history = []
        self.start_time = None
        self.timer_running = False
        self.language = "中文"
        self.voter_registry = {}
        self.vote_lock = threading.Lock()
        self.blockchain = []
        self.admin_password = "wwy2008"
        self.searcher = None  # 默认不启用IP定位
        self.shared_code = hashlib.md5(str(time.time()).encode()).hexdigest()[:6]
        self.sync_lock = threading.Lock()

        # 初始化音效
        pygame.mixer.init()
        self.button_sound = pygame.mixer.Sound("button_click.wav") if os.path.exists("button_click.wav") else None

        # 创建主框架
        self.main_frame = ttk.Frame(root)
        self.main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # 显示欢迎界面
        self.show_welcome_screen()

        # 创建菜单
        self.create_language_menu()
        self.create_admin_menu()

        # 启动网络监听服务
        self.start_network_listener()

    def _configure_styles(self):
        """配置样式"""
        self.style.theme_use('clam')
        self.style.configure('.', background=StyleConfig.BACKGROUND)
        self.style.configure('TButton',
                             font=StyleConfig.FONT_NORMAL,
                             borderwidth=0,
                             background=StyleConfig.SECONDARY,
                             foreground="white")
        self.style.map('TButton',
                       background=[('active', StyleConfig.PRIMARY)])

    def start_network_listener(self):
        """启动网络监听服务"""

        def listener():
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.settimeout(5)
                s.bind(('0.0.0.0', 65432))
                while True:
                    try:
                        data, addr = s.recvfrom(1024)
                        if data.decode().startswith("SYNC:"):
                            code = data.decode().split(":")[1]
                            if code == self.shared_code:
                                with self.sync_lock:
                                    s.sendto(json.dumps({
                                        'candidates': self.candidates,
                                        'votes': self.votes,
                                        'history': self.history
                                    }).encode(), addr)
                    except socket.timeout:
                        continue
                    except Exception as e:
                        print(f"网络错误: {str(e)}")

        threading.Thread(target=listener, daemon=True).start()

    def create_admin_menu(self):
        """创建管理员菜单"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        admin_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="管理", menu=admin_menu)
        admin_menu.add_command(label="高级后台", command=self.show_admin_panel)
        admin_menu.add_command(label="生成共享代码", command=self.generate_share_code)
        admin_menu.add_command(label="重置系统", command=self.reset_system)

    def reset_system(self):
        """重置投票系统"""
        if messagebox.askyesno("确认重置", "这将清除所有数据，继续吗？"):
            self.candidates = []
            self.votes = {}
            self.history = []
            self.blockchain = []
            self.voter_registry = {}
            self.shared_code = hashlib.md5(str(time.time()).encode()).hexdigest()[:6]
            self.show_welcome_screen()
            messagebox.showinfo("系统重置", "所有数据已清除")

    def generate_share_code(self):
        """生成共享代码用于同步"""
        share_window = tk.Toplevel(self.root)
        share_window.title("共享投票")
        share_window.geometry("400x400")

        code_label = tk.Label(share_window,
                              text=f"共享代码: {self.shared_code}",
                              font=("微软雅黑", 14),
                              fg=StyleConfig.PRIMARY)
        code_label.pack(pady=20)

        qr = qrcode.QRCode(version=1, box_size=10, border=4)
        qr_data = f"VOTE_SYNC:{self.shared_code}"
        qr.add_data(qr_data)
        qr.make(fit=True)
        img = qr.make_image(fill_color="black", back_color="white")
        img = img.resize((200, 200), Image.LANCZOS)  # 修复此处
        photo = ImageTk.PhotoImage(img)

        panel = tk.Label(share_window, image=photo)
        panel.image = photo
        panel.pack(pady=10)

        sync_frame = tk.Frame(share_window)
        sync_btn = ttk.Button(sync_frame,
                              text="同步数据",
                              command=self.sync_voting_data,
                              style='TButton')
        sync_btn.pack(side=tk.LEFT, padx=5)

        new_code_btn = ttk.Button(sync_frame,
                                  text="生成新代码",
                                  command=lambda: [setattr(self, 'shared_code',
                                                           hashlib.md5(str(time.time()).encode()).hexdigest()[:6]),
                                                   share_window.destroy(),
                                                   self.generate_share_code()])
        new_code_btn.pack(side=tk.RIGHT, padx=5)
        sync_frame.pack(pady=10)

    def sync_voting_data(self):
        """同步投票数据"""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.settimeout(5)
                s.sendto(f"SYNC:{self.shared_code}".encode(), ('127.0.0.1', 65432))
                data, _ = s.recvfrom(65535)
                remote_data = json.loads(data.decode())

                with self.sync_lock:
                    self.candidates = remote_data['candidates']
                    self.votes = remote_data['votes']
                    self.history = remote_data['history']
                    self.blockchain = []
                    for record in self.history:
                        self.add_to_blockchain(record[0], record[2], record[3], record[4], record[5])
                    messagebox.showinfo("同步成功", "数据已同步更新！")
                    self.show_welcome_screen()
        except Exception as e:
            messagebox.showerror("同步失败", f"错误: {str(e)}")

    def create_language_menu(self):
        """创建语言菜单"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        lang_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="语言/Language", menu=lang_menu)
        lang_menu.add_command(label="中文", command=lambda: self.change_language("中文"))
        lang_menu.add_command(label="English", command=lambda: self.change_language("English"))

    def change_language(self, lang):
        """切换语言"""
        self.language = lang
        self.show_welcome_screen()
        self.update_all_widgets()

    def update_all_widgets(self):
        """更新所有界面元素的语言"""
        # 更新菜单
        self.create_language_menu()
        self.create_admin_menu()

        # 更新当前界面
        if hasattr(self, 'main_frame'):
            self.show_welcome_screen()

    def clear_frame(self):
        """清除框架中的所有组件"""
        for widget in self.main_frame.winfo_children():
            widget.destroy()

    def create_rounded_button(self, parent, text, command):
        """创建圆角按钮"""
        btn_frame = tk.Frame(parent, bg=StyleConfig.BACKGROUND)
        btn = tk.Button(btn_frame,
                        text=text,
                        font=StyleConfig.FONT_NORMAL,
                        bg=StyleConfig.SECONDARY,
                        fg="white",
                        activebackground=StyleConfig.PRIMARY,
                        relief="flat",
                        borderwidth=0,
                        command=lambda: (command(), self.play_button_sound()),
                        padx=StyleConfig.BTN_PADDING,
                        pady=8)
        btn.pack(padx=5, pady=5)
        return btn_frame

    def play_button_sound(self):
        """播放按钮音效"""
        if self.button_sound:
            self.button_sound.play()

    def show_welcome_screen(self):
        """显示欢迎界面"""
        self.clear_frame()

        self.main_frame.grid_rowconfigure(0, weight=1)
        self.main_frame.grid_rowconfigure(1, weight=8)
        self.main_frame.grid_rowconfigure(2, weight=1)
        self.main_frame.grid_columnconfigure(0, weight=1)
        self.main_frame.grid_columnconfigure(1, weight=1)

        title_text = "极简投票系统" if self.language == "中文" else "Minimal Voting System"
        title = tk.Label(self.main_frame,
                         text=title_text,
                         font=StyleConfig.FONT_TITLE,
                         bg=StyleConfig.BACKGROUND,
                         fg=StyleConfig.TEXT)
        title.grid(row=0, column=0, columnspan=2, pady=(40, 20))

        btn_container = tk.Frame(self.main_frame, bg=StyleConfig.BACKGROUND)
        btn_container.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=20, pady=20)

        buttons = []
        if self.language == "中文":
            buttons = [
                ("初始化候选人", self.setup_candidates),
                ("开始投票", self.start_voting_session),
                ("查看结果", self.display_analytics),
                ("导出数据", self.export_data),
                ("投票理由分析", self.show_reason_analysis),
                ("区块链记录", self.show_blockchain)
            ]
        else:
            buttons = [
                ("Initialize Candidates", self.setup_candidates),
                ("Start Voting", self.start_voting_session),
                ("View Results", self.display_analytics),
                ("Export Data", self.export_data),
                ("Vote Reason Analysis", self.show_reason_analysis),
                ("Blockchain Records", self.show_blockchain)
            ]

        for i, (text, cmd) in enumerate(buttons):
            btn = self.create_rounded_button(btn_container, text, cmd)
            btn.grid(row=0, column=i, padx=15, pady=15, sticky="nsew")
            btn_container.grid_columnconfigure(i, weight=1)

    def setup_candidates(self):
        """设置候选人"""
        self.candidates = []
        while True:
            if self.language == "中文":
                name = simpledialog.askstring("添加候选人", "输入姓名 (留空结束):", parent=self.root)
                if not name:
                    if len(self.candidates) < 2:
                        messagebox.showwarning("提示", "至少需要2位候选人！")
                        continue
                    break
                desc = simpledialog.askstring("候选人介绍", f"输入{name}的简介:", parent=self.root)
            else:
                name = simpledialog.askstring("Add Candidate", "Enter name (empty to finish):", parent=self.root)
                if not name:
                    if len(self.candidates) < 2:
                        messagebox.showwarning("Warning", "At least 2 candidates needed!")
                        continue
                    break
                desc = simpledialog.askstring("Candidate Info", f"Enter {name}'s description:", parent=self.root)

            self.candidates.append(
                {'name': name, 'description': desc or ("暂无介绍" if self.language == "中文" else "No description")})

        confirm_msg = f"已添加 {len(self.candidates)} 位候选人" if self.language == "中文" else f"Added {len(self.candidates)} candidates"
        messagebox.showinfo("完成" if self.language == "中文" else "Completed", confirm_msg)
        self.show_welcome_screen()

    def create_candidate_card(self, parent, candidate):
        """创建候选人卡片"""
        frame = tk.Frame(parent, bg="white", bd=0)
        frame.pack(fill="x", pady=10, padx=10)

        btn = tk.Button(frame,
                        text=candidate['name'],
                        font=StyleConfig.FONT_NORMAL,
                        bg=StyleConfig.SECONDARY,
                        fg="white",
                        activebackground=StyleConfig.PRIMARY,
                        relief="flat",
                        command=lambda: self.register_vote(candidate['name']))
        btn.pack(side="left", fill="x", expand=True, padx=10, pady=5)

        info_btn = tk.Button(frame,
                             text="ℹ️",
                             font=("Arial", 10),
                             command=lambda: self.show_candidate_info(candidate))
        info_btn.pack(side="right", padx=5)

        return frame

    def show_candidate_info(self, candidate):
        """显示候选人详情"""
        info_window = tk.Toplevel(self.root)
        info_window.title("候选人详情" if self.language == "中文" else "Candidate Info")

        tk.Label(info_window,
                 text=f"{'姓名' if self.language == '中文' else 'Name'}: {candidate['name']}",
                 font=StyleConfig.FONT_NORMAL).pack(pady=5)

        tk.Label(info_window,
                 text=f"{'简介' if self.language == '中文' else 'Description'}:",
                 font=StyleConfig.FONT_NORMAL).pack()

        text = tk.Text(info_window, width=40, height=8, wrap=tk.WORD)
        text.insert("1.0", candidate['description'])
        text.config(state="disabled")
        text.pack(pady=10, padx=10)

    def start_voting_session(self):
        """开始投票会话"""
        if len(self.candidates) < 2:
            err_msg = "请先初始化候选人！" if self.language == "中文" else "Please initialize candidates first!"
            messagebox.showerror("错误" if self.language == "中文" else "Error", err_msg)
            return

        self.votes = {c['name']: 0 for c in self.candidates}
        self.clear_frame()
        self.start_time = datetime.now()
        self.timer_running = True

        control_bar = tk.Frame(self.main_frame, bg=StyleConfig.BACKGROUND)
        control_bar.pack(fill="x", pady=10)

        self.timer_label = tk.Label(control_bar,
                                    text="投票时长：00:00:00" if self.language == "中文" else "Voting Duration: 00:00:00",
                                    font=("微软雅黑", 12),
                                    bg=StyleConfig.BACKGROUND,
                                    fg=StyleConfig.TIMER_COLOR)
        self.timer_label.pack(side="left", padx=20)
        self.update_timer()

        end_btn_text = "结束投票" if self.language == "中文" else "End Voting"
        self.create_rounded_button(control_bar, end_btn_text, self.end_voting_session).pack(side="right", padx=20)
        share_btn_text = "分享投票" if self.language == "中文" else "Share Voting"
        self.create_rounded_button(control_bar, share_btn_text, self.share_voting).pack(side="right", padx=20)

        main_container = tk.Frame(self.main_frame, bg=StyleConfig.BACKGROUND)
        main_container.pack(fill="both", expand=True, padx=20, pady=20)

        left_pane = tk.Frame(main_container, bg=StyleConfig.BACKGROUND)
        left_pane.pack(side="left", fill="both", expand=True, padx=(0, 10))

        for candidate in self.candidates:
            self.create_candidate_card(left_pane, candidate)

        reason_frame = tk.Frame(left_pane, bg=StyleConfig.BACKGROUND)
        reason_label_text = "投票理由（限200字）：" if self.language == "中文" else "Vote Reason (max 200 chars):"
        tk.Label(reason_frame, text=reason_label_text, font=("微软雅黑", 11)).pack(anchor="w")

        self.reason_text = tk.Text(reason_frame, height=6, wrap=tk.WORD)
        reason_scroll = ttk.Scrollbar(reason_frame, command=self.reason_text.yview)
        self.reason_text.configure(yscrollcommand=reason_scroll.set)

        self.reason_text.pack(side="left", fill="both", expand=True)
        reason_scroll.pack(side="right", fill="y")
        reason_frame.pack(fill="x", pady=20)

        right_pane = tk.Frame(main_container, bg=StyleConfig.BACKGROUND)
        right_pane.pack(side="right", fill="both", expand=True, padx=(10, 0))

        notebook = ttk.Notebook(right_pane)
        stats_frame = ttk.Frame(notebook)
        trends_frame = ttk.Frame(notebook)
        wordcloud_frame = ttk.Frame(notebook)

        notebook.add(stats_frame, text="实时统计" if self.language == "中文" else "Live Stats")
        notebook.add(trends_frame, text="投票趋势" if self.language == "中文" else "Trends")
        notebook.add(wordcloud_frame, text="实时词云" if self.language == "中文" else "Word Cloud")
        notebook.pack(fill="both", expand=True)

        self.stats_canvas = tk.Canvas(stats_frame, bg=StyleConfig.BACKGROUND)
        self.stats_canvas.pack(fill="both", expand=True)

        self.trends_canvas = tk.Canvas(trends_frame, bg=StyleConfig.BACKGROUND)
        self.trends_canvas.pack(fill="both", expand=True)

        self.setup_live_wordcloud(wordcloud_frame)

        self.update_live_stats()
        self.draw_chart()

    def setup_live_wordcloud(self, parent):
        """设置实时词云"""
        self.wordcloud_canvas = tk.Canvas(parent, bg="white", width=600, height=400)
        self.wordcloud_canvas.pack(fill="both", expand=True)
        self.update_wordcloud()

    def update_wordcloud(self):
        """更新词云"""
        try:
            all_reasons = ' '.join([h[3] for h in self.history if h[3]])
            if not all_reasons:
                return

            self.wordcloud_canvas.delete("all")
            wordcloud = WordCloud(width=600, height=400, background_color="white", font_path="msyh.ttc").generate(
                all_reasons)

            plt.figure(figsize=(6, 4))
            plt.imshow(wordcloud, interpolation='bilinear')
            plt.axis("off")
            plt.tight_layout()

            plt.savefig("temp_wc.png", dpi=100)
            img = Image.open("temp_wc.png")
            photo = ImageTk.PhotoImage(img)

            self.wordcloud_canvas.create_image(300, 200, image=photo)
            self.wordcloud_canvas.image = photo

        except Exception as e:
            print(f"词云更新失败: {str(e)}")

        if self.timer_running:
            self.root.after(30000, self.update_wordcloud)

    def share_voting(self):
        """分享投票"""
        share_window = tk.Toplevel(self.root)
        share_window.title("分享投票" if self.language == "中文" else "Share Voting")
        share_window.geometry("400x400")

        # 生成二维码
        qr = qrcode.QRCode(version=1, box_size=10, border=4)
        qr_data = f"VOTE_SYNC:{self.shared_code}"
        qr.add_data(qr_data)
        qr.make(fit=True)
        img = qr.make_image(fill_color="black", back_color="white")
        img = img.resize((200, 200), Image.LANCZOS)  # 修复此处
        photo = ImageTk.PhotoImage(img)

        # 显示二维码
        qr_label = tk.Label(share_window, image=photo)
        qr_label.image = photo
        qr_label.pack(pady=10)

        # 显示说明文字
        tk.Label(share_window,
                 text="扫描二维码或使用共享代码进行同步" if self.language == "中文" else "Scan QR Code or use the shared code for synchronization").pack()

        # 显示共享代码
        code_label = tk.Label(share_window, text=f"共享代码: {self.shared_code}", font=("微软雅黑", 12),
                              fg=StyleConfig.PRIMARY)
        code_label.pack(pady=10)

        # 分享到平台按钮
        btn_frame = tk.Frame(share_window)
        btn_frame.pack(pady=10)

        platforms = [
            ("微信", "#2DC100"),
            ("QQ", "#12B7F5"),
            ("微博", "#E6162D")
        ]

        for platform, color in platforms:
            btn = tk.Button(btn_frame, text=platform, width=8, bg=color, fg="white",
                            command=lambda p=platform: self.share_to_platform(p))
            btn.pack(side="left", padx=5)

    def share_to_platform(self, platform):
        """模拟分享到平台"""
        if self.language == "中文":
            messagebox.showinfo("分享成功", f"已模拟分享到{platform}")
        else:
            messagebox.showinfo("Success", f"Shared to {platform} (simulated)")

    def end_voting_session(self):
        """结束投票会话"""
        self.timer_running = False
        self.show_wordcloud()
        self.show_welcome_screen()

    def update_timer(self):
        """更新计时器"""
        if self.timer_running:
            elapsed = datetime.now() - self.start_time
            hours, remainder = divmod(elapsed.total_seconds(), 3600)
            minutes, seconds = divmod(remainder, 60)
            time_str = f"{int(hours):02}:{int(minutes):02}:{int(seconds):02}"

            if self.language == "中文":
                self.timer_label.config(text=f"投票时长：{time_str}")
            else:
                self.timer_label.config(text=f"Duration: {time_str}")
            self.root.after(1000, self.update_timer)

    def register_vote(self, candidate):
        """注册投票"""
        user_ip = self.get_user_ip()
        device_id = self.get_device_id()
        current_time = datetime.now()

        with self.vote_lock:
            voter_key = f"{user_ip}_{device_id}"
            if voter_key in self.voter_registry:
                last_vote_time = self.voter_registry[voter_key]
                if current_time - last_vote_time < timedelta(minutes=5):
                    err_msg = "您已经投过票，请5分钟后再试！" if self.language == "中文" else "Vote cooldown: 5 minutes"
                    messagebox.showerror("错误" if self.language == "中文" else "Error", err_msg)
                    return

            self.voter_registry[voter_key] = current_time

        reason = self.reason_text.get("1.0", "end-1c").strip()[:200]
        self.votes[candidate] += 1
        vote_id = self.generate_vote_id()
        self.history.append((vote_id, current_time.strftime("%Y-%m-%d %H:%M:%S"),
                             candidate, reason, user_ip, device_id))

        self.reason_text.delete("1.0", tk.END)
        self.update_live_stats()
        self.draw_chart()
        self.update_wordcloud()
        self.show_vote_animation(candidate)
        self.add_to_blockchain(vote_id, candidate, reason, user_ip, device_id)

        if len(self.history) % 3 == 0:
            recommendation = self.add_ai_recommendation()
            if recommendation:
                messagebox.showinfo("AI推荐" if self.language == "中文" else "AI Tip", recommendation)

    def generate_vote_id(self):
        """生成投票ID"""
        return hashlib.sha256(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}{uuid.uuid4()}".encode()).hexdigest()[:16]

    def get_user_ip(self):
        """获取用户IP"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1"

    def get_device_id(self):
        """获取设备ID"""
        return hashlib.md5(str(uuid.getnode()).encode()).hexdigest()[:16]

    def update_live_stats(self):
        """更新实时统计"""
        self.stats_canvas.delete("all")
        sorted_votes = sorted(self.votes.items(), key=lambda x: -x[1])
        total_votes = sum(self.votes.values()) or 1

        y_pos = 20
        for idx, (name, votes) in enumerate(sorted_votes, 1):
            # 绘制候选人卡片背景
            self.stats_canvas.create_rectangle(20, y_pos - 10, 380, y_pos + 50,
                                               fill="white",
                                               outline=StyleConfig.CARD_SHADOW)

            # 绘制进度条
            progress_width = 360 * votes / total_votes
            self.stats_canvas.create_rectangle(120, y_pos + 30,
                                               120 + progress_width, y_pos + 40,
                                               fill=StyleConfig.SECONDARY)

            # 绘制排名
            self.stats_canvas.create_text(40, y_pos + 20,
                                          text=f"#{idx}",
                                          font=("微软雅黑", 12, "bold"),
                                          fill=StyleConfig.PRIMARY)

            # 绘制候选人名称
            self.stats_canvas.create_text(120, y_pos + 20,
                                          text=name,
                                          font=("微软雅黑", 11),
                                          anchor="w",
                                          fill=StyleConfig.TEXT)

            # 绘制票数和百分比
            percentage = f"{votes / total_votes:.1%}"
            self.stats_canvas.create_text(320, y_pos + 20,
                                          text=f"{votes}票 ({percentage})" if self.language == "中文" else f"{votes} votes ({percentage})",
                                          font=("微软雅黑", 11),
                                          fill=StyleConfig.SECONDARY)

            y_pos += 70

    def draw_chart(self):
        """绘制图表"""
        self.trends_canvas.delete("all")
        if not self.history:
            return

        time_counts = defaultdict(int)
        for record in self.history:
            hour = datetime.strptime(record[1], "%Y-%m-%d %H:%M:%S").strftime("%H:00")
            time_counts[hour] += 1

        max_count = max(time_counts.values()) or 1
        canvas_width = self.trends_canvas.winfo_width()
        canvas_height = self.trends_canvas.winfo_height()

        self.trends_canvas.create_line(50, canvas_height - 50, canvas_width - 50, canvas_height - 50, width=2)
        self.trends_canvas.create_line(50, 50, 50, canvas_height - 50, width=2)

        sorted_times = sorted(time_counts.items())
        points = []
        for i, (time_str, count) in enumerate(sorted_times):
            x = 50 + i * (canvas_width - 100) // len(time_counts)
            y = canvas_height - 50 - (count / max_count) * (canvas_height - 100)
            points.append((x, y))

            self.trends_canvas.create_text(x, canvas_height - 40,
                                           text=time_str,
                                           font=("微软雅黑", 8),
                                           angle=45,
                                           anchor="ne")

        if len(points) > 1:
            self.trends_canvas.create_line(points,
                                           fill=StyleConfig.SECONDARY,
                                           width=2,
                                           smooth=True)

        for x, y in points:
            self.trends_canvas.create_oval(x - 3, y - 3, x + 3, y + 3,
                                           fill=StyleConfig.PRIMARY,
                                           outline="white")

    def show_vote_animation(self, candidate):
        """显示投票动画"""
        popup = tk.Toplevel(self.root)
        popup.overrideredirect(True)
        x = self.root.winfo_x() + (self.root.winfo_width() // 2 - 100)
        y = self.root.winfo_y() + (self.root.winfo_height() // 2 - 100)
        popup.geometry(f"200x200+{x}+{y}")

        canvas = tk.Canvas(popup, bg=StyleConfig.BACKGROUND)
        canvas.pack(fill="both", expand=True)

        particles = []
        for _ in range(20):
            particles.append({
                'x': 100,
                'y': 100,
                'vx': random.uniform(-5, 5),
                'vy': random.uniform(-10, -5),
                'life': 30
            })

        def animate():
            nonlocal particles
            canvas.delete("all")
            new_particles = []

            for p in particles:
                p['x'] += p['vx']
                p['y'] += p['vy']
                p['vy'] += 0.5
                p['life'] -= 1

                if p['life'] > 0:
                    canvas.create_oval(p['x'] - 3, p['y'] - 3, p['x'] + 3, p['y'] + 3,
                                       fill=StyleConfig.ACCENT)
                    new_particles.append(p)

            particles = new_particles
            if particles:
                popup.after(50, animate)
            else:
                popup.destroy()

        animate()

    def add_ai_recommendation(self):
        """添加AI推荐"""
        if not hasattr(self, 'ai_model'):
            self.ai_model = {
                'vectorizer': TfidfVectorizer(),
                'similarities': None
            }

            reasons = [h[3] for h in self.history if h[3]]
            if reasons:
                try:
                    tfidf_matrix = self.ai_model['vectorizer'].fit_transform(reasons)
                    self.ai_model['similarities'] = cosine_similarity(tfidf_matrix)
                except Exception as e:
                    print(f"AI模型初始化失败: {str(e)}")
                    return

        if self.ai_model.get('similarities') is not None and len(self.history) > 0:
            last_reason = self.history[-1][3] if self.history else ""
            if last_reason:
                try:
                    input_vec = self.ai_model['vectorizer'].transform([last_reason])
                    similarities = cosine_similarity(input_vec, self.ai_model['vectorizer'].transform(
                        [h[3] for h in self.history if h[3]]))
                    most_similar_index = similarities.argmax()
                    recommended_candidate = self.history[most_similar_index][2]

                    if self.language == "中文":
                        return f"智能推荐: {recommended_candidate}"
                    else:
                        return f"AI Recommendation: {recommended_candidate}"
                except Exception as e:
                    print(f"AI推荐失败: {str(e)}")
        return ""

    def display_analytics(self):
        """显示数据分析"""
        if not self.votes:
            messagebox.showerror("错误" if self.language == "中文" else "Error",
                                 "尚无投票数据！" if self.language == "中文" else "No voting data yet!")
            return

        self.generate_result_charts()

        analytics_window = tk.Toplevel(self.root)
        analytics_window.title("数据分析" if self.language == "中文" else "Analytics")
        analytics_window.geometry("1400x900")

        notebook = ttk.Notebook(analytics_window)

        image_frame = ttk.Frame(notebook)
        self.show_result_images(image_frame)

        table_frame = ttk.Frame(notebook)
        self._create_results_table(table_frame)

        chart_frame = ttk.Frame(notebook)
        self._create_pie_chart(chart_frame)

        trend_frame = ttk.Frame(notebook)
        self._create_advanced_analysis(trend_frame)

        notebook.add(image_frame, text="图表快照")
        notebook.add(table_frame, text="详细数据")
        notebook.add(chart_frame, text="图表分析")
        notebook.add(trend_frame, text="趋势分析")
        notebook.pack(expand=True, fill="both")

    def generate_result_charts(self):
        """生成并保存结果图表"""
        # 饼图
        fig = plt.figure(figsize=(8, 8))
        total = sum(self.votes.values())
        if total > 0:
            labels = [f"{k} ({v}票)" for k, v in self.votes.items()]
            sizes = [v / total for v in self.votes.values()]
            explode = [0.1 if max(sizes) == s else 0 for s in sizes]

            plt.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',
                    shadow=True, startangle=140, colors=StyleConfig.CHART_COLORS)
            plt.title("投票分布" if self.language == "中文" else "Vote Distribution", fontsize=14)
            plt.axis('equal')
            plt.savefig("vote_pie.png", dpi=100, bbox_inches='tight')
            plt.close()

        # 趋势图
        fig = plt.figure(figsize=(12, 6))
        time_counts = defaultdict(int)
        for record in self.history:
            hour = datetime.strptime(record[1], "%Y-%m-%d %H:%M:%S").strftime("%H:00")
            time_counts[hour] += 1

        times = sorted(time_counts.keys())
        counts = [time_counts[t] for t in times]

        plt.plot(times, counts, marker='o', linestyle='-', color=StyleConfig.SECONDARY)
        plt.fill_between(times, counts, color=StyleConfig.SECONDARY, alpha=0.2)
        plt.title("投票趋势" if self.language == "中文" else "Voting Trend", fontsize=14)
        plt.xlabel("时间" if self.language == "中文" else "Time", fontsize=12)
        plt.ylabel("票数" if self.language == "中文" else "Votes", fontsize=12)
        plt.xticks(rotation=45)
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.savefig("vote_trend.png", dpi=100, bbox_inches='tight')
        plt.close()

    def show_result_images(self, parent):
        """显示生成的图表图片"""
        try:
            img_frame = tk.Frame(parent)
            img_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)

            # 饼图
            pie_img = Image.open("vote_pie.png")
            pie_img = pie_img.resize((500, 500), Image.LANCZOS)  # 修复此处
            pie_photo = ImageTk.PhotoImage(pie_img)
            pie_label = tk.Label(img_frame, image=pie_photo)
            pie_label.image = pie_photo
            pie_label.pack(side=tk.LEFT, padx=20)

            # 趋势图
            trend_img = Image.open("vote_trend.png")
            trend_img = trend_img.resize((700, 400), Image.LANCZOS)  # 修复此处
            trend_photo = ImageTk.PhotoImage(trend_img)
            trend_label = tk.Label(img_frame, image=trend_photo)
            trend_label.image = trend_photo
            trend_label.pack(side=tk.RIGHT, padx=20)
        except Exception as e:
            print(f"图片加载失败: {str(e)}")

    def _create_results_table(self, parent):
        """创建结果表格"""
        columns = ("排名", "候选人", "票数", "占比", "最新投票理由") if self.language == "中文" else (
            "Rank", "Candidate", "Votes", "Percentage", "Latest Vote Reason")
        tree = ttk.Treeview(parent, columns=columns, show="headings", selectmode="none")
        col_widths = [60, 150, 80, 100, 300]
        for col, width in zip(columns, col_widths):
            tree.heading(col, text=col)
            tree.column(col, width=width, anchor="center")

        total = sum(self.votes.values())
        sorted_data = sorted(self.votes.items(), key=lambda x: -x[1])
        for rank, (name, votes) in enumerate(sorted_data, 1):
            percentage = f"{votes / total:.1%}" if total > 0 else "0%"
            last_reason = next((h[3] for h in reversed(self.history) if h[2] == name), "")
            tree.insert("", "end", values=(rank, name, votes, percentage, last_reason))

        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

    def _create_pie_chart(self, parent):
        """创建饼图"""
        canvas = tk.Canvas(parent, bg="white", width=400, height=400)
        canvas.pack(pady=50)
        total = sum(self.votes.values())
        if total == 0:
            canvas.create_text(200, 200,
                               text="无投票数据" if self.language == "中文" else "No voting data",
                               font=StyleConfig.FONT_NORMAL)
            return

        colors = StyleConfig.CHART_COLORS
        sorted_votes = sorted(self.votes.items(), key=lambda x: -x[1])
        start_angle = 0

        for idx, (name, votes) in enumerate(sorted_votes):
            extent = 360 * votes / total
            if idx == len(sorted_votes) - 1:
                extent = 360 - start_angle
            canvas.create_arc(100, 100, 300, 300,
                              start=start_angle,
                              extent=extent,
                              fill=colors[idx % len(colors)],
                              outline="white")
            start_angle += extent

    def _create_advanced_analysis(self, parent):
        """创建高级分析图表"""
        canvas = tk.Canvas(parent, bg="white", width=800, height=600)
        canvas.pack(pady=20, padx=20)

        if not self.history:
            canvas.create_text(400, 300,
                               text="暂无投票数据" if self.language == "中文" else "No voting data",
                               font=StyleConfig.FONT_NORMAL)
            return

        time_votes = defaultdict(int)
        for timestamp, _, _ in self.history:
            date_str = timestamp.split()[0]
            time_votes[date_str] += 1

        dates = sorted(time_votes.keys())
        max_votes = max(time_votes.values()) or 1
        chart_height = 500
        chart_width = 700
        bar_width = chart_width // len(dates)

        canvas.create_line(50, chart_height - 50, chart_width + 50, chart_height - 50, width=2)
        canvas.create_line(50, 50, 50, chart_height - 50, width=2)

        for i, date in enumerate(dates):
            x = 50 + i * bar_width
            y_bottom = chart_height - 50
            vote_count = time_votes[date]
            bar_height = (vote_count / max_votes) * (chart_height - 100)

            canvas.create_rectangle(
                x, y_bottom - bar_height, x + bar_width - 10, y_bottom,
                fill=StyleConfig.SECONDARY,
                outline="white"
            )
            canvas.create_text(x + bar_width // 2, y_bottom + 20, text=date, font=("微软雅黑", 8))
            canvas.create_text(x - 20, y_bottom - bar_height - 10, text=str(vote_count), font=("微软雅黑", 8))

        title_text = "每日投票趋势" if self.language == "中文" else "Daily Voting Trends"
        canvas.create_text(400, 20, text=title_text, font=("微软雅黑", 14, "bold"))

    def export_data(self):
        """导出数据"""
        try:
            with open("voting_data.csv", "w", newline="", encoding="utf-8-sig") as f:
                writer = csv.writer(f)
                if self.language == "中文":
                    writer.writerow(["投票ID", "投票时间", "候选人", "得票数", "投票理由", "IP地址", "设备ID"])
                else:
                    writer.writerow(
                        ["Vote ID", "Vote Time", "Candidate", "Vote Count", "Vote Reason", "IP Address", "Device ID"])

                sorted_history = sorted(self.history, key=lambda x: x[1])
                for vote_id, timestamp, candidate, reason, ip, device_id in sorted_history:
                    writer.writerow([vote_id, timestamp, candidate, self.votes[candidate], reason, ip, device_id])

            messagebox.showinfo("导出成功" if self.language == "中文" else "Export Success",
                                "数据已保存为 voting_data.csv" if self.language == "中文" else "Data saved as voting_data.csv")
        except PermissionError:
            messagebox.showerror("导出失败" if self.language == "中文" else "Export Failed",
                                 "文件正在被其他程序占用" if self.language == "中文" else "File is being used")
        except Exception as e:
            messagebox.showerror("导出失败" if self.language == "中文" else "Export Failed",
                                 f"发生错误: {str(e)}" if self.language == "中文" else f"Error: {str(e)}")

    def show_reason_analysis(self):
        """显示投票理由分析"""
        analysis_window = tk.Toplevel(self.root)
        analysis_window.title("投票理由分析" if self.language == "中文" else "Vote Reason Analysis")
        analysis_window.geometry("1000x600")

        try:
            all_reasons = ' '.join([h[3] for h in self.history if h[3]])
            if not all_reasons:
                tk.Label(analysis_window,
                         text="暂无投票理由数据" if self.language == "中文" else "No vote reason data").pack()
                return

            # 生成词云
            wordcloud = WordCloud(width=800, height=400, background_color="white", font_path="msyh.ttc").generate(
                all_reasons)

            # 创建图表
            fig = plt.figure(figsize=(10, 5))
            plt.imshow(wordcloud, interpolation='bilinear')
            plt.axis("off")

            # 嵌入到Tkinter界面
            canvas = FigureCanvasTkAgg(fig, master=analysis_window)
            canvas.draw()
            canvas.get_tk_widget().pack(fill="both", expand=True)

        except Exception as e:
            tk.Label(analysis_window,
                     text=f"分析失败: {str(e)}" if self.language == "中文" else f"Analysis failed: {str(e)}").pack()

    def show_wordcloud(self):
        """显示词云图"""
        wordcloud_window = tk.Toplevel(self.root)
        wordcloud_window.title("投票理由词云图" if self.language == "中文" else "Vote Reasons Word Cloud")
        wordcloud_window.geometry("1000x600")

        try:
            all_reasons = ' '.join([h[3] for h in self.history if h[3]])
            if not all_reasons:
                tk.Label(wordcloud_window,
                         text="暂无投票理由数据" if self.language == "中文" else "No vote reason data").pack()
                return

            # 生成词云
            wordcloud = WordCloud(width=800, height=400, background_color="white", font_path="msyh.ttc").generate(
                all_reasons)

            # 创建图表
            fig = plt.figure(figsize=(10, 5))
            plt.imshow(wordcloud, interpolation='bilinear')
            plt.axis("off")

            # 嵌入到Tkinter界面
            canvas = FigureCanvasTkAgg(fig, master=wordcloud_window)
            canvas.draw()
            canvas.get_tk_widget().pack(fill="both", expand=True)

        except Exception as e:
            tk.Label(wordcloud_window,
                     text=f"生成词云图失败: {str(e)}" if self.language == "中文" else f"Failed to generate word cloud: {str(e)}").pack()

    def show_blockchain(self):
        """显示区块链记录"""
        blockchain_window = tk.Toplevel(self.root)
        blockchain_window.title("区块链记录" if self.language == "中文" else "Blockchain Records")
        blockchain_window.geometry("1000x600")

        columns = ("区块哈希", "投票ID", "候选人", "投票理由", "IP地址", "设备ID", "时间戳", "前区块哈希")
        tree = ttk.Treeview(blockchain_window, columns=columns, show="headings", selectmode="none")
        col_widths = [150, 150, 100, 200, 100, 100, 150, 150]
        for col, width in zip(columns, col_widths):
            tree.heading(col, text=col)
            tree.column(col, width=width, anchor="center")

        for block in self.blockchain:
            tree.insert("", "end", values=(
                block["block_hash"],
                block["vote_id"],
                block["candidate"],
                block["reason"],
                block["ip"],
                block["device_id"],
                block["timestamp"],
                block["previous_hash"]
            ))

        scrollbar = ttk.Scrollbar(blockchain_window, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

    def add_to_blockchain(self, vote_id, candidate, reason, ip, device_id):
        """添加投票记录到区块链"""
        previous_hash = self.get_latest_block_hash()
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        block_data = {
            "vote_id": vote_id,
            "candidate": candidate,
            "reason": reason,
            "ip": ip,
            "device_id": device_id,
            "timestamp": timestamp,
            "previous_hash": previous_hash
        }
        block_str = json.dumps(block_data, sort_keys=True)
        block_hash = hashlib.sha256(block_str.encode()).hexdigest()
        self.blockchain.append({
            "block_hash": block_hash,
            "vote_id": vote_id,
            "candidate": candidate,
            "reason": reason,
            "ip": ip,
            "device_id": device_id,
            "timestamp": timestamp,
            "previous_hash": previous_hash
        })

    def get_latest_block_hash(self):
        """获取最新区块哈希"""
        if not self.blockchain:
            return "0" * 64
        return self.blockchain[-1]["block_hash"]

    def show_admin_panel(self):
        """显示高级后台"""
        password = simpledialog.askstring("管理员验证", "输入密码：", show='*')
        if password != self.admin_password:
            messagebox.showerror("错误", "密码错误")
            return

        admin_window = tk.Toplevel(self.root)
        admin_window.title("高级后台")
        admin_window.geometry("1400x800")

        pane = ttk.PanedWindow(admin_window, orient=tk.HORIZONTAL)
        left_pane = ttk.Frame(pane)
        right_pane = ttk.Frame(pane)
        pane.add(left_pane)
        pane.add(right_pane)
        pane.pack(fill=tk.BOTH, expand=True)

        # 左面板：数据表格
        columns = ["时间", "候选人", "理由", "IP", "设备ID", "地区"]
        tree = ttk.Treeview(left_pane, columns=columns, show="headings")
        for col in columns:
            tree.heading(col, text=col)
            tree.column(col, width=150 if col == "地区" else 150)

        # 右面板：地图展示
        map_frame = tk.Frame(right_pane)
        map_frame.pack(fill=tk.BOTH, expand=True)

        # 加载数据并生成地图
        geo_data = defaultdict(int)
        for record in self.history:
            ip = record[4]
            region = "未知"
            if self.searcher:
                try:
                    data = self.searcher.memorySearch(ip)
                    region = data["region"].decode('utf-8').split('|')[3]
                    geo_data[region] += 1
                except:
                    pass
            tree.insert("", "end", values=(record[1], record[2], record[3], ip, record[5], region))

        # 生成热力图
        if geo_data:
            try:
                self.geo = Geo()
                self.geo.add_schema(maptype="china")
                for region, count in geo_data.items():
                    self.geo.add_coordinate(region, region)
                    self.geo.add(region, [list(z) for z in zip([region], [count])])
                self.geo.set_global_opts(
                    visualmap_opts=opts.VisualMapOpts(max_=max(geo_data.values())),
                    title_opts=opts.TitleOpts(title="投票分布热力图")
                )
                self.geo.render_notebook()
                map_html = self.geo.render_embed()
                webview = tk.Label(map_frame, text=map_html, bg="white")
                webview.pack(fill=tk.BOTH, expand=True)
            except Exception as e:
                tk.Label(right_pane, text=f"地图加载失败: {str(e)}").pack()
        else:
            tk.Label(right_pane, text="暂无地图数据").pack()

        # 组件布局
        scroll = ttk.Scrollbar(left_pane)
        tree.configure(yscrollcommand=scroll.set)
        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scroll.pack(side=tk.RIGHT, fill=tk.Y)


if __name__ == "__main__":
    root = tk.Tk()
    app = VotingApp(root)
    root.mainloop()